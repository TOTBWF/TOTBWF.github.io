<head>
    <title>An Introduction to Proof Refinement and Tactic Languages with Refinery</title>
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/syntax.css">
    <script type="text/javascript"
            src="http://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
</head>
<article>
    <h1 id="an-introduction-to-proof-refinement-and-tactic-languages-with-refinery">An Introduction to Proof Refinement and Tactic Languages with Refinery</h1>
<p>One of the most interesting things about typed functional programing is the idea that a type can be seen as a proposition, and a program as a proof. When we view programming through this lens, we see that type checking is proof verification, and type inference is finding the most general proposition that a proof proves. But there is one interesting aspect of theorem proving that we are missing, the holy grail of automated reasoning: proof synthesis. Before diving into this, we should first take a bit of a diversion into Proof Theory.</p>
<h1 id="the-structure-of-proofs">The Structure of Proofs</h1>
<p>Every proof starts with a theorem, and every theorem presents a goal, namely, to provide some sort of evidence that the theorem is actually true. From there, we can use the rules available to us to either directly prove the goal, or to break down the goal into further subgoals. A proof is complete when there are no more subgoals left to solve. From this perspective, we can see that a proof forms a tree. As an example, lets do a very quick proof that <span class="math inline">\(A \Rightarrow B \Rightarrow A \land B\)</span>.</p>
<p>Our initial goal is <span class="math inline">\(A \Rightarrow B \Rightarrow A \land B\)</span>. To prove this, we can assume that <span class="math inline">\(A\)</span> is true, and see if we can prove <span class="math inline">\(B \Rightarrow A \land B\)</span>. This gives us the subgoal. <span class="math display">\[A \vdash B \Rightarrow A \land B\]</span> As a quick notational note, you should read <span class="math inline">\(H \vdash P\)</span> as “Asssuming H is true, prove P”. Continuing our proof, let us repeat the same step for <span class="math inline">\(B\)</span>, giving us the subgoal: <span class="math display">\[A,B \vdash A \land B\]</span> To prove <span class="math inline">\(A \land B\)</span>, we need to create 2 subgoals, one for <span class="math inline">\(A\)</span> and the other for <span class="math inline">\(B\)</span>. Now our subgoals look like this: <span class="math display">\[A,B \vdash A\]</span> <span class="math display">\[A,B \vdash B\]</span> In both of our subgoals, we have assumed the thing we are trying to prove is true, so the proof is complete! The full proof tree looks like this:</p>
<p><img src="/tikz/proof-tree.png" class="centered" /></p>
<p>Putting on our Curry-Howard glasses, this proof tree looks suspiciously like an abstract syntax tree…</p>
<p><img src="/tikz/syntax-tree.png" class="centered" /></p>
<p>If only we had some way to programatically construct syntax trees…</p>
<h2 id="proof-synthesis-as-metaprogramming">Proof Synthesis as Metaprogramming</h2>
<p>As it turns out, just as we can create a programming language that creates programs, we can create a programming language that actually creates proofs! This sort of language is what as known as a <em>Tactic Language</em>, and is a key component of most proof assistants.</p>
<p>Let’s sketch out a little toy language for simply typed lambda calculus with products.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Var</span> <span class="fu">=</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Term</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    <span class="fu">=</span> <span class="dt">Hole</span> <span class="co">-- We will get to this later...</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">    <span class="fu">|</span> <span class="dt">Var</span> <span class="dt">Var</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">    <span class="fu">|</span> <span class="dt">Lam</span> <span class="dt">Var</span> <span class="dt">Term</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">    <span class="fu">|</span> <span class="dt">Pair</span> <span class="dt">Term</span> <span class="dt">Term</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">    <span class="kw">deriving</span> (<span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb1-9" data-line-number="9">    </a>
<a class="sourceLine" id="cb1-10" data-line-number="10"><span class="kw">data</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">    <span class="fu">=</span> <span class="dt">TVar</span> <span class="dt">Var</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12">    <span class="fu">|</span> <span class="dt">TArrow</span> <span class="dt">Type</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13">    <span class="fu">|</span> <span class="dt">TPair</span> <span class="dt">Type</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb1-14" data-line-number="14">    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</a></code></pre></div>
<p>Now, let’s design a tactic language! We will be using <a href="https://github.com/TOTBWF/refinery">refinery</a> to handle the nitty gritty bits, so we can focus on playing with the tactics side of things.</p>
<p>The first thing we need to be able to do handle assumptions. To do this, we shall define a new type <code>Judgement</code>, which carries a list of variables bound to types, along with the goal we are trying to prove.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Judgement</span> <span class="fu">=</span> <span class="dt">Judgement</span> [(<span class="dt">Var</span>, <span class="dt">Type</span>)] <span class="dt">Type</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  <span class="kw">deriving</span> (<span class="dt">Show</span>)</a></code></pre></div>
<p>Now, on to the core type of <code>refinery</code>, <code>TacticT goal extract m a</code>.</p>
</article>
